<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Conversor de 츼udio Imersivo HD</title>
  <style>
    body {
      background: #121212;
      color: white;
      font-family: sans-serif;
      text-align: center;
      padding: 30px;
    }
    input, button {
      padding: 10px;
      margin: 10px;
    }
    audio {
      margin-top: 20px;
      width: 90%;
    }
  </style>
</head>
<body>
  <h2>游꿚 Conversor de 츼udio Imersivo HD</h2>

  <input type="file" id="inputAudio" accept="audio/*"><br>
  <button onclick="playWithEffects()">Tocar com efeitos</button>
  <button onclick="downloadProcessed()">游꿧 Baixar 츼udio com Efeitos</button>

  <audio id="player" controls></audio>

  <script>
    const inputAudio = document.getElementById("inputAudio");
    const audioElement = document.getElementById("player");

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let sourceNode, panner, filter, reverb, destination, recorder, chunks = [];

    let audioURL;

    // Cria reverb simples
    function createReverb() {
      const convolver = audioCtx.createConvolver();
      const length = audioCtx.sampleRate * 3;
      const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
      for (let c = 0; c < 2; c++) {
        let channel = impulse.getChannelData(c);
        for (let i = 0; i < length; i++) {
          channel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2); // decaimento
        }
      }
      convolver.buffer = impulse;
      return convolver;
    }

    inputAudio.addEventListener("change", () => {
      const file = inputAudio.files[0];
      if (!file) return;
      if (audioURL) URL.revokeObjectURL(audioURL);
      audioURL = URL.createObjectURL(file);
      audioElement.src = audioURL;
    });

    async function playWithEffects() {
      await audioCtx.resume(); // Garante que o contexto esteja ativo

      if (!audioElement.src) return alert("Selecione um 치udio primeiro.");

      // Cria n칩s
      sourceNode = audioCtx.createMediaElementSource(audioElement);
      panner = audioCtx.createStereoPanner();
      panner.pan.value = 0.4; // leve efeito est칠reo

      filter = audioCtx.createBiquadFilter();
      filter.type = "lowshelf";
      filter.frequency.value = 1000;
      filter.gain.value = 10; // HD boost

      reverb = createReverb();

      destination = audioCtx.createMediaStreamDestination();

      // Encadeia os n칩s
      sourceNode.connect(panner);
      panner.connect(filter);
      filter.connect(reverb);
      reverb.connect(audioCtx.destination);       // para ouvir
      reverb.connect(destination);                // para gravar

      // Inicia grava칞칚o
      recorder = new MediaRecorder(destination.stream);
      chunks = [];

      recorder.ondataavailable = e => chunks.push(e.data);
      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const downloadLink = document.createElement("a");
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.download = "audio_imersivo_hd.webm";
        downloadLink.click();
      };

      recorder.start();

      // Toca o 치udio
      audioElement.currentTime = 0;
      audioElement.play();

      // Para grava칞칚o ap칩s a dura칞칚o do 치udio
      setTimeout(() => recorder.stop(), audioElement.duration * 1000);
    }

    function downloadProcessed() {
      if (!recorder || recorder.state === "inactive") {
        alert("Reproduza o 치udio com efeitos primeiro.");
      } else {
        // A grava칞칚o j치 ser치 baixada automaticamente ap칩s terminar
        alert("O 치udio ser치 baixado automaticamente ap칩s a reprodu칞칚o.");
      }
    }
  </script>
</body>
</html>
