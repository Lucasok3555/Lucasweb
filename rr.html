<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Sandbox Blocos - Debug</title>
<style>
  html,body { height:100%; margin:0; font-family:Arial,Helvetica,sans-serif; background:#87CEEB; }
  #canvasContainer { width:100%; height:100%; position:relative; overflow:hidden; }
  #overlay {
    position:absolute; left:12px; top:12px; z-index:50;
    background:rgba(0,0,0,0.45); color:#fff; padding:8px 10px; border-radius:8px; font-size:13px;
  }
  #controlsMobile { position:absolute; right:12px; bottom:12px; z-index:50; display:none; gap:8px; }
  .btn { background: rgba(255,255,255,0.12); color:#fff; padding:10px 12px; border-radius:8px; font-size:14px; user-select:none; }
  #log {
    position:absolute; left:12px; bottom:12px; z-index:60; max-width:45%; max-height:35%; overflow:auto;
    background:rgba(0,0,0,0.55); color:#fff; padding:8px; border-radius:8px; font-size:12px;
  }
  #errorBanner {
    position:absolute; left:50%; transform:translateX(-50%); top:50%; z-index:100; background:#b33; color:#fff;
    padding:16px 20px; border-radius:8px; display:none; font-weight:bold;
  }
  #hint { font-size:12px; color:#eee; margin-top:6px; opacity:0.9; }
</style>
</head>
<body>
<div id="canvasContainer"></div>
<div id="overlay">
  <div>Clique/Tap = colocar bloco • Shift+Clique = quebrar</div>
  <div id="hint">Abra no Chrome se possível. Se aparecer erro, veja o painel abaixo.</div>
</div>

<div id="controlsMobile" style="display:none;">
  <div id="btnPlace" class="btn">Colocar</div>
  <div id="btnBreak" class="btn">Quebrar</div>
</div>

<pre id="log"></pre>
<div id="errorBanner"></div>

<!-- Three.js UMD build + OrbitControls (compatível com a maioria dos browsers) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  const logEl = document.getElementById('log');
  function log(...args){ console.log(...args); logEl.textContent += args.map(a=> (typeof a === 'object'? JSON.stringify(a): String(a)) ).join(' ') + '\\n'; logEl.scrollTop = logEl.scrollHeight; }
  function showError(msg){ const b = document.getElementById('errorBanner'); b.textContent = msg; b.style.display = 'block'; log('ERRO: ' + msg); }

  // Captura erros JS e mostra na tela
  window.addEventListener('error', function(e){ showError('Erro JS: ' + e.message + ' (veja console)'); console.error(e); });
  window.addEventListener('unhandledrejection', function(e){ showError('Promise rejeitada: ' + e.reason); console.error(e); });

  // Container
  const container = document.getElementById('canvasContainer');

  // Tentativa de criar renderer (captura falha WebGL)
  let renderer;
  try {
    renderer = new THREE.WebGLRenderer({ antialias: true });
  } catch(e){ showError('WebGL não disponível no navegador'); log(e); return; }

  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.display = 'block';
  container.appendChild(renderer.domElement);

  // Cena e câmera
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(10, 12, 16);

  // Luzes
  const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(10,20,10); scene.add(dir);

  // Helpers (grid)
  const grid = new THREE.GridHelper(40, 40, 0x444444, 0x888888);
  grid.position.y = -0.5;
  scene.add(grid);

  // Controls (Orbit para testar)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Raycaster / mouse
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Array de blocos (meshes)
  const blocks = [];
  const BLOCK_SIZE = 1;
  const cubeGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

  // Cores simples para tipos
  const materials = {
    default: new THREE.MeshLambertMaterial({ color: 0x8B5A2B }),
    grass: new THREE.MeshLambertMaterial({ color: 0x2E8B57 }),
    stone: new THREE.MeshLambertMaterial({ color: 0x888888 })
  };

  // Cria chão pequeno (20x20)
  const half = 10;
  for(let x=-half; x<half; x++){
    for(let z=-half; z<half; z++){
      const m = new THREE.Mesh(cubeGeo, (Math.random()>0.9?materials.stone:materials.default).clone());
      m.position.set(x + 0.5, 0, z + 0.5);
      m.userData.isBlock = true;
      scene.add(m);
      blocks.push(m);
    }
  }

  // Função para adicionar bloco na posição (inteiro)
  function addBlock(ix, iy, iz, mat=materials.default){
    const m = new THREE.Mesh(cubeGeo, mat.clone());
    m.position.set(ix + 0.5, iy + 0.5, iz + 0.5);
    m.userData.isBlock = true;
    scene.add(m);
    blocks.push(m);
    log('Adicionado bloco em', ix,iy,iz);
    return m;
  }

  // Remove bloco mesh
  function removeBlock(mesh){
    scene.remove(mesh);
    const i = blocks.indexOf(mesh);
    if(i>=0) blocks.splice(i,1);
    if(mesh.geometry) mesh.geometry.dispose && mesh.geometry.dispose();
    if(mesh.material) mesh.material.dispose && mesh.material.dispose();
    log('Removido bloco');
  }

  // Converte ponto para coords inteiros do bloco (floor)
  function worldToBlockCoords(v){
    return { x: Math.floor(v.x), y: Math.floor(v.y), z: Math.floor(v.z) };
  }

  // Interação clique / toque:
  // - clique normal: coloca bloco acima do bloco clicado
  // - shift+clique: remove bloco clicado
  renderer.domElement.addEventListener('pointerdown', function(ev){
    ev.preventDefault();
    mouse.x = (ev.clientX / renderer.domElement.clientWidth) * 2 - 1;
    mouse.y = - (ev.clientY / renderer.domElement.clientHeight) * 2 + 1;
    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(blocks, false);
    if(hits.length === 0){
      log('Nenhum bloco atingido');
      return;
    }
    const hit = hits[0];
    const mesh = hit.object;
    if(ev.shiftKey || ev.pointerType === 'touch' && ev.altKey){ // altKey fallback
      removeBlock(mesh);
    } else {
      // lugar para novo bloco: posição do face + normal
      const normal = hit.face.normal.clone();
      const pos = hit.point.clone().add(normal.multiplyScalar(0.5));
      const coords = worldToBlockCoords(pos);
      addBlock(coords.x, coords.y, coords.z, materials.grass);
    }
  });

  // Mobile UI: mostrar botões se for mobile
  function isMobile(){ return /Mobi|Android/i.test(navigator.userAgent); }
  if(isMobile()){
    document.getElementById('controlsMobile').style.display = 'flex';
    // botão place => faz um clique virtual
    document.getElementById('btnPlace').addEventListener('touchstart', function(e){
      e.preventDefault();
      // coloca bloco à frente da câmera (3 unidades) se não atingir
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const target = camera.position.clone().add(dir.multiplyScalar(4));
      const coords = worldToBlockCoords(target);
      addBlock(coords.x, coords.y, coords.z, materials.grass);
    }, {passive:false});
    document.getElementById('btnBreak').addEventListener('touchstart', function(e){
      e.preventDefault();
      // quebra o bloco mais próximo da câmera na direção
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      ray.set(camera.position, dir);
      const hits = ray.intersectObjects(blocks, true);
      if(hits.length) removeBlock(hits[0].object);
    }, {passive:false});
  }

  // Resize
  window.addEventListener('resize', function(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Render loop
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  log('Cena iniciada. Se a tela continuar branca:');
  log('- abra o console remoto (chrome://inspect) no PC para ver erros do device;');
  log('- tente abrir no Google Chrome (Android) se estiver usando outro navegador;');
  log('- verifique se há overlays (apps tipo "Root missing" podem estar bloqueando a página);');

})();
</script>
</body>
</html>
